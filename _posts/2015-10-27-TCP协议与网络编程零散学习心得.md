---
layout: default
---

# TCP协议与网络编程 零散学习心得
---
- RTO(Retransmission Timeout)：RTO为TCP超时重传的控制参数之一，决定了一个报文发送之后，多久没有收到ACK就会重发该报文。	其计算方式与RTT(Round Trip Time)的值有关，会使用TCP配置中的最大RTT值、最小RTT值以及实际测量到的RTT值做一个计算得到。每次进行重传，下一次RTO的值会呈指数级增长。- 重传次数：重传次数为可配置选项，默认为3次，如果重传全部失败，可能会发送RESET包给对端，取消本次传输，然后向用户层返回传输失败结果。- TCP的TIMESTAMP选项：在TCP的传输中，发送多个报文可能只会收到一个ACK，所以数据发送之后，过多久才判断超时是一个问题。另外一方面，报文的序列号只有32位长，如果发送数据量够大，那么可能导致序列号溢出造成反转。TS选项的出现解决了上面的问题，一方面可以通过TS测量RTT，获得网络传输的时延，从而制定一个合理的RTO时间；另一方面，通过比较TS大小，可以知道本次的报文是不是最新的报文，这样即使序列号反转，也不影响正常的传输。

- TCP连接建立的三次握手：TCP连接建立的主要流程是：A端发送SYN -> B端回复ACK/SYN -> A端回复ACK。  
发送SYN的时候，会带上初始序列号、滑动窗口大小、可以接受的最大分片等信息。其中最大分片信息用于限定发送方每个TCP报文的长度，如果超过这个长度，就会被IP层分片，而IP层的分片是不可靠的传输，所以分片需要由TCP来完成。  
在实际的实现中，内核使用两个队列完成对连接的管理，一个称为半连接队列，一个称为accept队列。  
服务端对一个socket进行监听，当收到客户端发来连接请求时（即收到SYN），内核会把SYN放入这个socket的半连接队列，这个队列的默认长度是1024，但如果开启了syncookies功能，那就相当于没有限制。  
如果一个连接完成了三次握手，进入established状态，那么内核会把这个连接放入accept队列，等待应用层取走。这个队列默认长度为128，如果满了，后面的连接会被drop掉。当应用层调用accept方法时，内核会从这个队列取出连接的信息，生成一个新的socket，然后给应用层返回socket的文件描述符。- TCP连接关闭的四次挥手：由于TCP是全双工传输，因此需要双方都进行关闭的操作，主要流程是：A端发送FIN -> B端回复ACK -> B端发送FIN -> A端回复ACK。  
收到FIN包后，TCP内核程序会向应用层提交一个文件结束符EOF，用来表明数据接收完毕。有一些应用程序需要得到EOF之后才会对数据进行处理。  主动发起关闭TCP连接的一端，收到对端发送来的FIN包之后，会回复最后一次ACK，然后进入TIME_WAIT状态。TW状态通常会持续2MSL的时间（一来一回），通常一个MSL是2分钟，且这个MSL是内核常数，除非重新编译，否则不能修改。  TW状态目的是确保其发送最后一个ACK已经到达对端（如果没有到达，则对端会重发FIN包）。其本质目的是为了保证老的连接所有的数据包要么到达，要么消失。如果没有TW状态的等待，可能导致一个TCP连接传输的数据，会被混入老的连接的数据，从而产生不可预知的错误。
- TIME\_WAIT状态会导致的问题：进入TW状态的连接依然占据资源，包括文件描述符和内存等，且占据的端口在TW期间不能复用。  对于客户端而言，如果客户端发起大量的短连接并主动断开，最终可能会导致无端口可用。  对于服务端而言，如果存在大量的TW状态连接，一方面会被占据很多的文件描述符，另一方面会消耗很多无意义的内存。- TIME\_WAIT连接的快速回收机制：尽快TW状态有 其存在意义，不过很多时候也会带来上面的问题，因此需要有相关机制去解决此类问题。其中一个方法是TW连接的快速回收机制。  TW连接的快速回收可以通过配置内核参数net.ipv4.tcp_tw_recycle来进行启用。启动之后，连接的TW状态不再需要等待2MSL的时间，而是只需要等待一个RTO时间。对应的，快速回收同样会面临TW状态本身用来解决的一些问题，比如被老连接的数据包混淆甚至被劫持，被重传的FIN包关闭等，于是需要相关手段去解决这些问题。其核心思想是快速把TW状态的连接回收，然后再制定一些规则尽可能的去排除老连接的数据，确保新连接的正确性。  快速回收机制使用的方法主要流程是这样的：   1.	TW状态的连接被回收之后，保存连接信息的四元组（tuple）已经消失，但还会在IP层保留一个peer对象用于描述对端机器信息，主要包含对端IP，最后一次通讯的时间戳等信息。   2.	制定一些规则去排除老连接，当一个TCP连接满足以下条件的时候，就会被拒绝：  1）	这个连接带了时间戳数据过来（TCP的时间戳功能通过修改tcp_timestamp参数来实现）；  2）	同一台peer机器曾在MSL秒内与本机发生过通讯；  3）	新连接带过来的时间戳小于该peer机器上次连接最后一次通讯带来的时间戳，且差值要大于初始重传窗口；  如果一个连接同时满足以上条件，则视为是老连接，从而拒绝连接请求。  此类机制的一个显著问题是在通讯网络有NAT设备的时候，会带来混乱性。假设某个集群的机器都通过一台NAT设备与服务器进行通讯，则这个集群的机器在经过NAT设备的时候，其IP都会被修改成NAT设备的IP，导致服务器无法依靠peer信息有效识别一个连接是否有效连接。  这个机制在实际应用中，也会带来其他问题，是一个不稳定的方法，因此在实际应用中，应要非常小心使用。  
- TIME_WAIT连接的重用机制：用于解决TW状态产生的问题的另外一种机制就是连接的重用机制。TW状态的快速回收机制只能说是一种优化，而TW的重用机制则是一种有规范方法的可行的解决方案。对于一个连接请求，如果该请求满足以下条件之一，则允许重用TW状态的连接：  1） 该请求的SYN包的序列号大于TW连接收到的最后一次FIN包的序列号；  2） 如果开启了时间戳，那么该请求的SYN包带来的时间戳比TW连接收到的最后一次FIN包的时间戳要大；对于1，因为新连接的起始序列号比老连接的FIN包大，所以即使老连接再有数据过来，也会落到窗口外面从而被抛弃，从而不会导致新连接被破坏。对于2，则是基于IP唯一性制定的。对于同一台机器而言，时间戳只增不减，因此只要能证明连接请求来自于同一台机器，且时间戳比上次通讯要大，则可以认为这个连接是新连接。于是相应的，在有NAT通讯环境中，由于多台机器共用IP，无法保证连接请求来自于同一台机器，所以2并不适用于有NAT的通讯环境。- RST包相关：RST包是TCP用来关闭异常连接的手段，RST包的发送端会立即丢弃发送缓冲区所有的数据，然后把RST包放入缓冲区发送。而接收端接收到RST包之后，会直接断开连接，并且不需要回复ACK。双方都会给应用层调用返回一个错误。通常在以下几种情况会导致TCP发送RST包：  
1）端口未打开：一个端口收到SYN包，然而这个端口并没有被监听，于是会直接回复一个RST包；  2）超时：如果发起方设置了connect_timeout，发送SYN包之后，等待ACK超时，就会给对端发送RST包；传输过程中的超时重传超过次数也会发送RST包给对端；类似的还有keepalive的超时；  3）非正常数据包：服务端监听端口的时候，收到一个不存在的连接的数据包，会直接回复RST包。对端收到RST之后，会给应用层返回connect reset by peer错误。这种情况通常出在服务端意外重启之后，服务端丢失了连接信息，但对端还是继续发送数据过来，于是会导致RST；如果是在正常连接的情况下，收到SYN包且其序列号落在窗口内（窗口外的包会直接丢弃），那么也会回复RST；如果连接是TW状态，且开启了TW连接的重用，那么这个连接收到不满足重用条件的SYN包，会回复RST；  4）其他情况：比如服务端关闭连接的时候，缓冲区还有数据，也会给对端返回RST；其他还有很多情况会导致RST的出现。- RST攻击：一个TCP的连接是由一个四元组唯一标识的：源IP，源端口，目标IP，目标端口。如果一个伪造的RST数据包，能把四元组填对，并解决序列号的问题使这个包的序列号落在连接的窗口内不会被抛弃，那么就能对正常的TCP连接造成影响，使其中断，这种工作方法被称为复位攻击。这种方法也会被一些人考虑用来终止TW状态的连接。

- 数据报长度：链路层数据帧长度介于46-1500字节；链路首部为14字节，尾部为4字节；IP首部为20字节（最多可拓展至60）；TCP首部为20字节（最多可拓展至60）；UDP首部为8字节。

- TCP和UDP的伪首部：伪首部是通过提取IP层相关数据，给TCP或者UDP数据报构造出来的一个首部，位于TCP或UDP报文的最前端。其目的是为了做校验，确定数据是否有正确传输。在实际传输过程中，并不存在，只有在计算校验值的时候才会构造出来再做校验。伪首部功能的启用是可选的。

- TCP连接的关闭机制：TCP的关闭可以通过调用close或者shutdown方法进行关闭，在不同场景下，会有不同效果：
  1. 理想的关闭情况：双方都处理完数据后，一方调用close方法发起主动关闭，另一方被动关闭，按正常四次挥手流程关闭连接；
  2. 半关闭：TCP提供了关闭本端连接之后，还能继续接受对端数据的功能，这种情况称为半关闭。半关闭的实现是依靠调用shutdown方法，shutdown可以通过一个参数指定要关闭的功能，枚举为：关闭读，关闭写，关闭读写。半关闭功能通常用于RPC（远程调用），《TCP/IP详解》中举了一个例子，通过rsh命令，在一台主机上远程调用另外一台机器的sort命令，本机需要把数据传输到远端机器，因为sort命令需要接收到文件结束符EOF才会开始工作，而TCP的FIN包会提交EOF，所以本机传完数据后，会关闭本端的写功能，亦即向远端发送FIN包，告诉远端我已经写完数据了。远端收到FIN包之后，才会开始执行sort命令，最后把sort的结果通过TCP传输回本机。这样一个过程就是半双工的工作过程。
  3. 多进程、线程下关闭TCP：多进程和进程和线程的创建都是通过clone系统调用来实现，只不过调用时的参数不一样。clone的系统调用中，有一个dup_fd方法会执行文件描述符的拷贝，以实现文件描述符的共享。  
进程fork的时候，会调用这个方法，拷贝文件描述符；线程创建的时候，如果指定了CLONE\_FILES标记位（即声明要共享父进程的文件描述符），也会调用这个方法，以实现对文件描述符的共享。通过这个方法，创建的进程、线程就能共享一个TCP连接。而在共享情况下的连接，关闭会按照一定的流程来进行。为了简化描述，下文的进程和线程意义等同。
     - close方法：如果某个进程调用close方法的话，共享的连接并不会马上关闭，而是要等所有共享这个连接的进程都调用close方法后，才会真正关闭。其原理是clone系统调用中，调用的dup_fd方法，里面会对文件描述符的引用进行计数，复制时+1，被close时-1。只有当引用计数为0的时候，close方法才会真正的走到tcp的close步骤。
     - shutdown方法：多进程不影响shutdown方法的调用，只要shutdown方法调用了，产生的效果会对所有的进程造成影响。

	close的调用还会遇到一些其他情况需要进行特定处理：  
	1. 对监听的socket调用close：当一个监听socket被进行关闭时，内核会从其半连接队列取出所有连接请求，然后对它们发送RST进行复位。对于那些已经连接完毕，进入了accept队列或者被accpet走的连接，则不会产生影响；  
	2. 对普通的established连接调用close：关闭过程中，会先检查接收缓冲区是否有未处理的数据，如果有未处理的数据，则会向对端发送RST来结束连接。这样做是为了通知对端虽然我成功接收了数据并回复了ACK，但实际上我并未对数据进行处理，因此这是一次失败的数据传输。如果没有未处理的数据，接下来会把FIN包放入发送缓冲区。排在FIN包前面可能还有未发送完的数据，默认情况下内核会把这些数据都发送完，最后发送FIN，进入四次挥手流程；   
	3. 启用了SO\_LINGER选项的连接：SO\_LINGER选项是为了更可靠的关闭TCP连接。如果启用了socket的SO\_LINGER选项，那么调用close的时候，会进入阻塞状态，等到发送缓冲区所有的数据都发送完毕，并且都收到ACK之后，close流程才会发送FIN包并返回。但如果socket设置成非阻塞，那么close的调用还是会立即返回，只是不到明确的成功/失败结果。  
SO\_LINGER选项可以设置一个超时时间，如果超时了还没完成所有的数据发送和确认，则会抛弃缓冲区所有数据，给close调用返回一个错误。如果超时时间设为0，那么调用close的时候，会立即抛弃缓冲区所有数据，并发送RST给对端。这种方式被称为强制关闭，当然应用场景比较有限，在关闭TIME\_WAIT连接的时候可以一试。
