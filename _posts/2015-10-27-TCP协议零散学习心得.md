---
layout: default
---

#	TCP协议零散学习心得
---

- RTO(Retransmission Timeout)：RTO为TCP超时重传的控制参数之一，决定了一个报文发送之后，多久没有收到ACK就会重发该报文。	其计算方式与RTT(Round Trip Time)的值有关，会使用TCP配置中的最大RTT值、最小RTT值以及实际测量到的RTT值做一个计算得到。每次进行重传，下一次RTO的值会呈指数级增长。

- 重传次数：重传次数为可配置选项，默认为3次，如果重传全部失败，可能会发送RESET包给对端，取消本次传输，然后向用户层返回传输失败结果。

- TCP的TIMESTAMP选项：在TCP的传输中，发送多个报文可能只会收到一个ACK，所以数据发送之后，过多久才判断超时是一个问题。另外一方面，报文的序列号只有32位长，如果发送数据量够大，那么可能导致序列号溢出造成反转。TS选项的出现解决了上面的问题，一方面可以通过TS测量RTT，获得网络传输的时延，从而制定一个合理的RTO时间；另一方面，通过比较TS大小，可以知道本次的报文是不是最新的报文，这样即使序列号反转，也不影响正常的传输。

- TCP连接关闭的四次挥手：由于TCP是全双工传输，因此需要双方都进行关闭的操作，主要流程是：A端发送FIN -> B端回复ACK -> B端发送FIN -> A端回复ACK。  
主动发起关闭TCP连接的一端，收到对端发送来的FIN包之后，会回复最后一次ACK，然后进入TIME_WAIT状态。TW状态通常会持续2MSL的时间（一来一回），通常一个MSL是2分钟，且这个MSL是内核常数，除非重新编译，否则不能修改。  
TW状态目的是确保其发送最后一个ACK已经到达对端（如果没有到达，则对端会重发FIN包）。其本质目的是为了保证老的连接所有的数据包要么到达，要么消失。如果没有TW状态的等待，可能导致一个TCP连接传输的数据，会被混入老的连接的数据，从而产生不可预知的错误。

- TIME_WAIT状态会导致的问题：进入TW状态的连接依然占据资源，包括文件描述符和内存等，且占据的端口在TW期间不能复用。  
对于客户端而言，如果客户端发起大量的短连接并主动断开，最终可能会导致无端口可用。  
对于服务端而言，如果存在大量的TW状态连接，一方面会被占据很多的文件描述符，另一方面会消耗很多无意义的内存。

- TIME_WAIT连接的快速回收机制：尽快TW状态有 其存在意义，不过很多时候也会带来上面的问题，因此需要有相关机制去解决此类问题。其中一个方法是TW连接的快速回收机制。  
TW连接的快速回收可以通过配置内核参数net.ipv4.tcp_tw_recycle来进行启用。启动之后，连接的TW状态不再需要等待2MSL的时间，而是只需要等待一个RTO时间。对应的，快速回收同样会面临TW状态本身用来解决的一些问题，比如被老连接的数据包混淆甚至被劫持，被重传的FIN包关闭等，于是需要相关手段去解决这些问题。其核心思想是快速把TW状态的连接回收，然后再制定一些规则尽可能的去排除老连接的数据，确保新连接的正确性。  
快速回收机制使用的方法主要流程是这样的：  
  1.	TW状态的连接被回收之后，保存连接信息的四元组（tuple）已经消失，但还会在IP层保留一个peer对象用于描述对端机器信息，主要包含对端IP，最后一次通讯的时间戳等信息。  
  2.	制定一些规则去排除老连接，当一个TCP连接满足以下条件的时候，就会被拒绝：  
1）	这个连接带了时间戳数据过来（TCP的时间戳功能通过修改tcp_timestamp参数来实现）；  
2）	同一台peer机器曾在MSL秒内与本机发生过通讯；  
3）	新连接带过来的时间戳小于该peer机器上次连接最后一次通讯带来的时间戳，且差值要大于初始重传窗口；  
如果一个连接同时满足以上条件，则视为是老连接，从而拒绝连接请求。  
此类机制的一个显著问题是在通讯网络有NAT设备的时候，会带来混乱性。假设某个集群的机器都通过一台NAT设备与服务器进行通讯，则这个集群的机器在经过NAT设备的时候，其IP都会被修改成NAT设备的IP，导致服务器无法依靠peer信息有效识别一个连接是否有效连接。  
这个机制在实际应用中，也会带来其他问题，是一个不稳定的方法，因此在实际应用中，应要非常小心使用。  

- TIME_WAIT连接的重用机制：用于解决TW状态产生的问题的另外一种机制就是连接的重用机制。TW状态的快速回收机制只能说是一种优化，而TW的重用机制则是一种有规范方法的可行的解决方案。对于一个连接请求，如果该请求满足以下条件之一，则允许重用TW状态的连接：  
1） 该请求的SYN包的序列号大于TW连接收到的最后一次FIN包的序列号；  
2） 如果开启了时间戳，那么该请求的SYN包带来的时间戳比TW连接收到的最后一次FIN包的时间戳要大；
对于1，因为新连接的起始序列号比老连接的FIN包大，所以即使老连接再有数据过来，也会落到窗口外面从而被抛弃，从而不会导致新连接被破坏。对于2，则是基于IP唯一性制定的。对于同一台机器而言，时间戳只增不减，因此只要能证明连接请求来自于同一台机器，且时间戳比上次通讯要大，则可以认为这个连接是新连接。于是相应的，在有NAT通讯环境中，由于多台机器共用IP，无法保证连接请求来自于同一台机器，所以2并不适用于有NAT通讯环境。

- RST包相关：RST包是TCP用来关闭异常连接的手段，RST包的发送端会立即丢弃发送缓冲区所有的数据，然后把RST包放入缓冲区发送。而接收端接收到RST包之后，会直接断开连接，并且不需要回复ACK。双方都会给应用层调用返回一个错误。通常在以下几种情况会导致TCP发送RST包：  
1）端口未打开：一个端口收到SYN包，然而这个端口并没有被监听，于是会直接回复一个RST包；  
2）超时：如果发起方设置了connect_timeout，发送SYN包之后，等待ACK超时，就会给对端发送RST包；传输过程中的超时重传超过次数也会发送RST包给对端；类似的还有keepalive的超时；  
3）非正常数据包：服务端监听端口的时候，收到一个不存在的连接的数据包，会直接回复RST包。对端收到RST之后，会给应用层返回connect reset by peer错误。这种情况通常出在服务端意外重启之后，服务端丢失了连接信息，但对端还是继续发送数据过来，于是会导致RST；如果是在正常连接的情况下，收到SYN包且其序列号落在窗口内（窗口外的包会直接丢弃），那么也会回复RST；如果连接是TW状态，且开启了TW连接的重用，那么这个连接收到不满足重用条件的SYN包，会回复RST；  
4）其他情况：比如服务端关闭连接的时候，缓冲区还有数据，也会给对端返回RST；其他还有很多情况会导致RST的出现。

- RST攻击：一个TCP的连接是由一个四元组唯一标识的：源IP，源端口，目标IP，目标端口。如果一个伪造的RST数据包，能把四元组填对，并解决序列号的问题使这个包的序列号落在连接的窗口内不会被抛弃，那么就能对正常的TCP连接造成影响，使其中断，这种工作方法被称为复位攻击。这种方法也会被一些人考虑用来终止TW状态的连接。

