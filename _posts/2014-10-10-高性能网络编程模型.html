---
layout: default
---

<head>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=Generator content="Microsoft Word 12 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Cambria;
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
@font-face
	{font-family:微软雅黑;
	panose-1:2 11 5 3 2 2 4 2 2 4;}
@font-face
	{font-family:Consolas;
	panose-1:2 11 6 9 2 2 4 3 2 4;}
@font-face
	{font-family:"\@宋体";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"\@微软雅黑";
	panose-1:2 11 5 3 2 2 4 2 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:"Calibri","sans-serif";}
h1
	{mso-style-link:"标题 1 Char";
	margin-right:0cm;
	margin-left:0cm;
	font-size:24.0pt;
	font-family:宋体;
	font-weight:bold;}
h2
	{mso-style-link:"标题 2 Char";
	margin-top:13.0pt;
	margin-right:0cm;
	margin-bottom:13.0pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:173%;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:"Cambria","serif";
	font-weight:bold;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{mso-style-link:"页眉 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	layout-grid-mode:char;
	border:none;
	padding:0cm;
	font-size:9.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{mso-style-link:"页脚 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:"Calibri","sans-serif";}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p
	{margin-right:0cm;
	margin-left:0cm;
	font-size:12.0pt;
	font-family:宋体;}
code
	{font-family:宋体;}
pre
	{mso-style-link:"HTML 预设格式 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:宋体;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{mso-style-link:"批注框文本 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:9.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:21.0pt;
	font-size:10.5pt;
	font-family:"Calibri","sans-serif";}
span.Char
	{mso-style-name:"页眉 Char";
	mso-style-link:页眉;}
span.Char0
	{mso-style-name:"页脚 Char";
	mso-style-link:页脚;}
span.1Char
	{mso-style-name:"标题 1 Char";
	mso-style-link:"标题 1";
	font-family:宋体;
	font-weight:bold;}
span.apple-converted-space
	{mso-style-name:apple-converted-space;}
span.HTMLChar
	{mso-style-name:"HTML 预设格式 Char";
	mso-style-link:"HTML 预设格式";
	font-family:宋体;}
span.keyword
	{mso-style-name:keyword;}
span.comment
	{mso-style-name:comment;}
span.number
	{mso-style-name:number;}
span.Char1
	{mso-style-name:"批注框文本 Char";
	mso-style-link:批注框文本;}
span.2Char
	{mso-style-name:"标题 2 Char";
	mso-style-link:"标题 2";
	font-family:"Cambria","serif";
	font-weight:bold;}
 /* Page Definitions */
 @page WordSection1
	{size:595.3pt 841.9pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	layout-grid:15.6pt;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body lang=ZH-CN link=blue vlink=purple style='text-justify-trim:punctuation'>

<div class=WordSection1 style='layout-grid:15.6pt'>

<h1 align=center style='text-align:center'>高性能网络编程模型</h1>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>是否每个团队都需要自己定制化的写一套成熟的网络框架，这就仁者见仁，智者见智。个人认为，系统核心模块尽量还是自己完全能够把控，任何定制化的需求都能够修改。虽然要开发一套非常成熟的网络框架，适用于各种应用场景，并且性能达到极致非常的困难，要么抽象程度太高理解与实现复杂，要么为了通用性能大打折扣。但是高性能网络编程的思想都是一样的。本文首先主要探讨介绍几种比较通用的多路<span
lang=EN-US>I/O</span>复用网络模型，然后再介绍网络编程通用的设计方法。</span></p>

<h2><span style='font-family:宋体'>网络模型</span></h2>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>1</span></b><b><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>）</span></b><b><span lang=EN-US
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>&nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>多进程并发连接处理模型</span></b></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'><img width=515 height=323 id="图片 1"
src="https://github.com/Gwan-He/Gwan-He.github.io/blob/master/images/image001.jpg"
alt="http://km.oa.com/files/post_photo/860/224860/ef1e862325ff9a1dcb9a22167ecc7cf51418203336.jpg"></span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>多进程并发连接处理模型如上图所示。最大的优势是不同进程之间互不影响，单个进程故障不影响其它子进程；主进程可监控子进程状态，当发现子进程退出时，可重新创建子进程继续服务，稳定性一般比多线程模型高。此模型创建主要包括以下几个步骤：</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>a) </span><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>主进程创建<span lang=EN-US>listen</span>套接字，再创建子进程；然后主进程监控各子进程的状态。<span
lang=EN-US><br>
b) </span>子进程中将<span lang=EN-US>listen</span>套接字的读事件注册到多路<span lang=EN-US>I/O</span>复用事件驱动中；<span
lang=EN-US><br>
c) </span>当<span lang=EN-US>listen</span>套接字有读<span lang=EN-US>IO</span>事件时，自动触发<span
lang=EN-US>accept</span>函数接收新的客户端；<span lang=EN-US><br>
d) </span>再将新连接<span lang=EN-US>fd</span>的读事件注册到多路<span lang=EN-US>I/O</span>复用事件驱动中；<span
lang=EN-US><br>
e) </span>当新连接<span lang=EN-US>fd</span>客户端发送数据时，自动触发新连接<span lang=EN-US>fd</span>的读<span
lang=EN-US>I/O</span>事件的回调函数接收数据；并判断是否构成一个完整的数据包；<span lang=EN-US><br>
f) </span>当接到一个完整的数据包后，再进行处理。由于处理方式不同，又衍生出各种模型的变种。<span lang=EN-US><br>
g) </span>当接收数据包处理完成后，再将新连接<span lang=EN-US>fd</span>的写事件注册到多路<span lang=EN-US>I/O</span>复用事件驱动中；<span
lang=EN-US><br>
h) </span>新连接<span lang=EN-US>fd</span>数据发送完成后，再将新连接<span lang=EN-US>fd</span>的写事件从多路<span
lang=EN-US>I/O</span>复用事件驱动中注销；</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>2</span></b><b><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>）</span></b><b><span lang=EN-US
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>&nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>单进程多线程并发处理模型</span></b></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp; &nbsp; &nbsp; </span><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>单进程多线程并发连接处理模型与多进程模型实现其实都差不多。都可以在主进程与主线程中监控<span
lang=EN-US>listen</span>套接字接收新连接，然后通过进程间或者线程间通讯将连接分发到各个子进程或子线程；也可以在子进程或者子线程中监控<span
lang=EN-US>listen</span>套接字接收新连接；例如<span lang=EN-US>Nginx</span>就是各个子进程都可接收新连接，而<span
lang=EN-US>memcached</span>则在主线程中接收新连接，然后通过管道再分发给各个子线程。不管是多进程还是多线程模型，都需要考虑各个进程或者线程间怎么样负载均衡。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>3</span></b><b><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>）</span></b><b><span lang=EN-US
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>&nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>单进程多处理线程模型（变种）</span></b></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp; &nbsp; &nbsp; </span><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>前面介绍的多进程与多线程并发处理模型对数据接收、数据包处理、数据发送其实完全是串行的。如一个连接并发同时发送二个数据包请求，一定是处理完第一个之后才会处理第二个。这就要求多进程与多线程模型所有连接数据包处理时间都差不多，如果数据包处理时间分布非常不均匀，当处理耗时比较大的数据包将会影响其它数据包的处理性能。例如<span
lang=EN-US>99.99%</span>数据包的数据处理时间都小于<span lang=EN-US>1ms</span>，但是有<span
lang=EN-US>0.01%</span>的数据处理时间要<span lang=EN-US>1s</span>。那么当处理<span
lang=EN-US>1s</span>数据包时，其它连接到此进程上的客户端都需要等待<span lang=EN-US>1s</span>。<span
lang=EN-US>Nginx</span>与<span lang=EN-US>memcached</span>业务形态基本每个连接的数据包处理的时间都差不多，所以可以使用上面的网络模型。为了平滑网络服务器的处理性能，数据包的处理方式不一样，就衍生出了其它的网络模型。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'><img width=492 height=337 id="图片 9"
src="https://github.com/Gwan-He/Gwan-He.github.io/blob/master/images/image002.jpg"
alt="http://avocado.oa.com/fconv/files/201412/78c69d92eb525bf45976e8974a2bf052.files/image002.jpg"></span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp; &nbsp; &nbsp; </span><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>如上图的单进程多处理线程的网络模型，就是在主线程中处理所有网络事件，创建多个工作子线程处理数据包，解决数据包处理时间分布不均匀的问题。由于数据包需要切换到<span
lang=EN-US>Worker</span>线程进行处理，处理完成就需要切换到主线程进行数据发送，对于一个数据包的处理，增加了二次上下文切换时间，另外对队列的读写也需要加锁，所以此模型比前面介绍的多进程与多线程处理模型性能要差些。此模型创建主要包括以下几个步骤：</span></p>

<p class=MsoListParagraph align=left style='margin-top:0cm;margin-right:0cm;
margin-bottom:12.0pt;margin-left:18.0pt;text-align:left;text-indent:-18.0pt;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>a)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>主线程先创建多个<span lang=EN-US>Worker</span>工作线程，工作线程阻塞在数据包处理队列；<span
lang=EN-US><br>
b) </span>主线程创建监听套接字，然后将监控套接字读事件注册到多路<span lang=EN-US>I/O</span>复用事件驱动中；<span
lang=EN-US><br>
c) </span>当<span lang=EN-US>listen</span>套接字有读<span lang=EN-US>IO</span>事件时，自动触发<span
lang=EN-US>accept</span>函数接收新的客户端；<span lang=EN-US><br>
d) </span>再将新连接<span lang=EN-US>fd</span>的读事件注册到多路<span lang=EN-US>I/O</span>复用事件驱动中；<span
lang=EN-US><br>
e) </span>当新连接<span lang=EN-US>fd</span>客户端发送数据时，自动触发新连接<span lang=EN-US>fd</span>的读<span
lang=EN-US>I/O</span>事件的回调函数接收数据；并判断是否构成一个完整的数据包；<span lang=EN-US><br>
f) </span>当接到一个完整的数据包，将数据包添加到数据处理队列；<span lang=EN-US><br>
g) Worker</span>线程从数据处理队列获取一个任务进行处理，处理完成再添加到<span lang=EN-US>fd</span>的发送队列。再将连接<span
lang=EN-US>fd</span>的写事件注册到多路<span lang=EN-US>I/O</span>复用事件驱动中；<span
lang=EN-US><br>
h) </span>新连接<span lang=EN-US>fd</span>数据发送完成后，再将新连接<span lang=EN-US>fd</span>的写事件从多路<span
lang=EN-US>I/O</span>复用事件驱动中注销；</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp;</span></p>

<h2><span style='font-family:宋体'>网络编程思想</span></h2>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>虽然服务器网络编程过程中由于业务场景不一样，选择的网络模型、上层网络协议、数据处理都可能不一样，但是仍然有不少东西是通过的，可以进行抽象与复用。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>1</span></b><b><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>）</span></b><b><span lang=EN-US
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>&nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>网络<span
lang=EN-US>socket</span>封装</span></b></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>其实就是对网络<span lang=EN-US>socket</span>函数进行简单的封装，虽然简单，但是复用程度非常的高，不管是哪种类型的服务器网络编程都是通用的。附件例子中的</span><b><span
lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>anet.cpp</span></b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>文件实现了对<span
lang=EN-US>socket</span>的封装。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>a) &nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>创建<span
lang=EN-US>Socket</span>并设置<span lang=EN-US>socketopt</span>属性</span></b></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>static</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> <b>int</b> anetCreateSocket(<b>char</b>
*err, <b>int</b> domain)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>int</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> anetNonBlock(<b>char</b> *err, <b>int</b>
fd)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>int</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> anetTcpNoDelay(<b>char</b> *err, <b>int</b>
fd)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>int</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> anetTcpKeepAlive(<b>char</b> *err, <b>int</b>
fd)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>int</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> anetSetSendBuffer(<b>char</b> *err, <b>int</b>
fd, <b>int</b> buffsize)</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>b)&nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>绑定地址，监听端口</span></b></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>int</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> anetTcpServer(<b>char</b> *err, <b>int</b>
port, <b>const</b> <b>char</b> *bindaddr)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>static</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> <b>int</b> anetListen(<b>char</b> *err, <b>int</b>
s, <b>struct</b> sockaddr *sa, socklen_t len)</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>c) &nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>接收新的客户端</span></b></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>static</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> <b>int</b> anetGenericAccept(<b>char</b>
*err, <b>int</b> s, <b>struct</b> sockaddr *sa, socklen_t *len)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>int</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> anetTcpServer(<b>char</b> *err, <b>int</b>
port, <b>const</b> <b>char</b> *bindaddr)</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>d)&nbsp;&nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>从<span
lang=EN-US>socket</span>读写数据</span></b></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>int</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> anetRead(<b>int</b> fd, <b>char</b>* buf, <b>int</b>
count)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>int</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> anetWrite(<b>int</b> fd, <b>char</b> *buf, <b>int</b>
count)</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>e)&nbsp;&nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>同步或者异步连接服务器端</span></b></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>int</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> anetTcpConnect(<b>char</b> *err, <b>char</b>
*addr, <b>int</b> port)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>int</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> anetTcpNonBlockConnect(<b>char</b> *err, <b>char</b>
*addr, <b>int</b> port)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>static</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> <b>int</b> anetTcpGenericConnect(<b>char</b>
*err, <b>char</b> *addr, <b>int</b> port, <b>int</b> flags)</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>2</span></b><b><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>）</span></b><b><span lang=EN-US
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>&nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>事件驱动</span></b></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp; &nbsp; &nbsp; &nbsp;</span><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>事件驱动的一种实现方式就是<span lang=EN-US>Reactor</span>模式。应用程序需要提供相应的接口并注册到<span
lang=EN-US>Reactor</span>上，如果相应的事件发生，<span lang=EN-US>Reactor</span>将主动调用应用程序注册的接口，这些接口又称为“回调函数”。典型的开源实现就是<span
lang=EN-US>libevent</span>。在<span lang=EN-US>socket</span>上注册<span lang=EN-US>I/O</span>读写事件，当<span
lang=EN-US>fd</span>上有可读写事件发现时，事件框架会调用这些回调函数处理相应的事件。所以使用<span lang=EN-US>Reactor</span>模型，必备的几个组件：事件源、<span
lang=EN-US>Reactor</span>框架、多路复用机制和事件处理程序。下面将描述怎么实现一个轻量级的<span lang=EN-US>Reactor</span>的事件处理框架。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>a)&nbsp;&nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>事件源</span></b></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp; &nbsp; &nbsp;Linux</span><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>上是文件描述符，<span lang=EN-US>Windows</span>上就是<span
lang=EN-US>Socket</span>或者<span lang=EN-US>Handle</span>了，程序在指定的句柄上注册关心的事件，比如<span
lang=EN-US>I/O</span>事件、超时事件、信号事件。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>b)&nbsp;&nbsp;event demultiplexer</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>——事件多路分发机制</span></b></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp; &nbsp; &nbsp;</span><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>由操作系统提供的<span lang=EN-US>I/O</span>多路复用机制，比如<span
lang=EN-US>select</span>和<span lang=EN-US>epoll</span>。上层关心的句柄（事件源）及其事件注册到<span
lang=EN-US>event demultiplexer</span>上；当有事件到达时，<span lang=EN-US>event
demultiplexer</span>会发出通知“在已经注册的句柄集中，一个或多个句柄的事件已经就绪”；程序收到通知后，就可以在非阻塞的情况下对事件进行处理了。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>c)&nbsp;&nbsp;&nbsp;Reactor</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>——反应器</span></b></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp; &nbsp; &nbsp;Reactor</span><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>，是事件管理的接口，内部使用<span lang=EN-US>event
demultiplexer</span>注册、注销事件；并运行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数处理事件。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>d)&nbsp;&nbsp;&nbsp;&nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>网络事件驱动实现</span></b></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp; &nbsp; &nbsp; &nbsp; </span><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>在附件中的</span><b><span lang=EN-US
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>event.cpp</span></b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>代码中实现了一个简单通用的网络<span
lang=EN-US>IO</span>事件与超时事件的处理框架。包括网络<span lang=EN-US>IO</span>读写事件的注册与注册，超时注册与注销。</span></p>

<p class=MsoNormal align=left style='margin-left:21.5pt;text-align:left;
text-indent:-18.0pt;line-height:15.45pt'><span lang=EN-US style='font-size:
10.0pt;font-family:Symbol;color:#333333'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>网络读写<span lang=EN-US>IO</span>事件注册函数</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:#888888'>/*</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span style='font-size:7.5pt;font-family:宋体;color:#888888'>将</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>fd</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>上读或者写事件注册到</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>Reactor</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>框架，并设置对应回调函数与对应的参数</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span style='font-size:7.5pt;font-family:宋体;color:#888888'>每个</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>fd</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>对应一个文件事件的结构体，首先判断添加的事件是否已经存在，防止重复调用</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>epoll_ctl</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span style='font-size:7.5pt;font-family:宋体;color:#888888'>影响性能，然后再设置相应的回调函数并注册到</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>epoll</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:#888888'>*/</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>int</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> event_add(event_base *base, <b>int</b> fd, <b>int</b>
mask, event_proc *proc, <b>void</b> *arg);</span></p>

<p class=MsoNormal align=left style='margin-left:21.5pt;text-align:left;
text-indent:-18.0pt;line-height:15.45pt'><span lang=EN-US style='font-size:
10.0pt;font-family:Symbol;color:#333333'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>网络事件读写<span lang=EN-US>IO</span>事件注销</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:#888888'>/*</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span style='font-size:7.5pt;font-family:宋体;color:#888888'>将</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>fd</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>上读或者写事件从</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>Reactor</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>框架上注销，如果</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>fd</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>上没有剩余任何事件需要监听，则从</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>epoll</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>中删除，否则修改</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:#888888'>*/</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>int</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> event_del(event_base *base, <b>int</b> fd, <b>int</b>
mask);</span></p>

<p class=MsoNormal align=left style='margin-left:21.5pt;text-align:left;
text-indent:-18.0pt;line-height:15.45pt'><span lang=EN-US style='font-size:
10.0pt;font-family:Symbol;color:#333333'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>事件驱动循环</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp; &nbsp; &nbsp; &nbsp;</span><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>由于<span lang=EN-US>epoll_wait</span>最后一个参数是超时时间，在事件驱动循环中这个<span
lang=EN-US>timeout</span>参数是动态计算的。可以通过小根堆保存每个超时事件，将<span lang=EN-US>timeout</span>设置为<span
lang=EN-US>top</span>结点的时间，就完美的将网络事件<span lang=EN-US>IO</span>与超时事件结合在一起。如下图所示：</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'><img width=527 height=119 id="图片 3"
src="https://github.com/Gwan-He/Gwan-He.github.io/blob/master/images/image003.jpg"
alt="http://avocado.oa.com/fconv/files/201412/78c69d92eb525bf45976e8974a2bf052.files/image003.jpg"></span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>在<span lang=EN-US>epoll</span>的事件循环中，每次都要计算<span lang=EN-US>timeout</span>时间，可以参考例子中的<span
lang=EN-US>timeout_next</span>函数。</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:#888888'>//</span><span style='font-size:7.5pt;font-family:宋体;color:#888888'>事件循环，当事件</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>“</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>就绪</span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:#888888'>”</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>状态时，调用注册事件的回调函数</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>void</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> event_dispatch(event_base *base)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>{</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp;&nbsp; </span><span lang=EN-US style='font-size:
7.5pt;font-family:Consolas;color:#888888'>//</span><span style='font-size:7.5pt;
font-family:宋体;color:#888888'>计算小根堆中，</span><span lang=EN-US style='font-size:
7.5pt;font-family:Consolas;color:#888888'>top</span><span style='font-size:
7.5pt;font-family:宋体;color:#888888'>结点的时间</span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:#888888'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>int</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> nfds = epoll_wait(base-&gt;epfd,
base-&gt;eevents, EPOLL_SIZE, timeout);</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>for</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'>( i = </span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:#008800'>0</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:black'>; i &lt;
nfds; i++)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>{</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; <b>struct</b> epoll_event *e = base-&gt;eevents
+ i;</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; <b>int</b> fd = e-&gt;data.fd;</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; <b>int</b> mask = </span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:#008800'>0</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:black'>;</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; file_event *fe = &amp;base-&gt;fevents[fd];</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; <b>if</b>( e-&gt;events &amp; EPOLLIN)mask |=
AE_READABLE;</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; <b>if</b>( e-&gt;events &amp; EPOLLOUT) mask |=
AE_WRITABLE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:#888888'>//</span><span style='font-size:7.5pt;font-family:宋体;color:#888888'>触发读事件的回调函数</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; <b>if</b>( fe-&gt;mask &amp; mask &amp;
AE_READABLE)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; {</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fe-&gt;rproc(base, fd,
fe-&gt;arg);</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; }</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:#888888'>/*</span><span style='font-size:7.5pt;font-family:宋体;color:#888888'>触发写事件的回调函数</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>,</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>这是为什么不是</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>if(e-&gt;events
&amp;EPOLLOUT)fe-&gt;wproc</span><span style='font-size:7.5pt;font-family:宋体;
color:#888888'>，是有原因。假设一个</span><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:#888888'>fd</span><span style='font-size:7.5pt;
font-family:宋体;color:#888888'>同时触发读事件与写事件，在读事件中出错，</span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:#888888;background:#F0F0F0'><br>
</span><span style='font-size:7.5pt;font-family:宋体;color:#888888'>我们将这个</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>fd</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>关闭，如果直接使用上面的写法，还会执行</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>wproc</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>函数</span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:#888888'>,</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>出错</span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:#888888'>;</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>现在增加一层</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>fe-&gt;mask</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>，那么</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>fd</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>关闭后会将</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>fe-&gt;mask</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>置位，不会再执行</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>wproc</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>函数</span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:#888888'>*/</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; <b>if</b>( fe-&gt;mask &amp; mask &amp;
AE_WRITABLE)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; {</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fe-&gt;wproc(base, fd,
fe-&gt;arg);</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; }</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>}</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:#888888'>//</span><span style='font-size:7.5pt;font-family:宋体;color:#888888'>处理超时事件</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>process_timeout(base);</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>}</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>3</span></b><b><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>）</span></b><b><span lang=EN-US
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>&nbsp;</span></b><b><span
lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>I/O</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>事件回调处理</span></b></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp; &nbsp; &nbsp;I/O</span><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>事件回调处理主要包括接收新连接、接收客户发送的数据与发送数据给客户端三块。对应例子中的<span
lang=EN-US>connsvr.cpp</span>文件。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>a)&nbsp;&nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>接收新连接（</span></b><span
lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>process_accept</span><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>）</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp; &nbsp; &nbsp;</span><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>接收新连接基本逻辑都一样，当有新连接时会触发<span
lang=EN-US>listenfd</span>的读事件回调函数<span lang=EN-US>process_accept</span>。但是由于每种场景不一样，定义的<span
lang=EN-US>conn</span>结构也相比较大，但是都包括接收缓冲、发送缓冲等信息。</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>void</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> process_accept(event_base *base, <b>int</b>
fd, <b>void</b> *privdata)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>{</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; cfd = anetTcpAccept(error_, fd, cip,
&amp;cport);</span><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:#888888'>//</span><span style='font-size:7.5pt;font-family:宋体;color:#888888'>接收新连接</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>anetNonBlock(error_, cfd);</span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:#888888'>//</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>设置</span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:#888888'>fd</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>相关属性</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; </span><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:#888888'>//</span><span style='font-size:7.5pt;
font-family:宋体;color:#888888'>创建连接的相关的结构，</span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:#888888'>create_conn</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>是变化部分，其它基本不变</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; <b>struct</b> conn *c = create_conn(base, cfd,
cip, cport);</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; event_add(base, cfd, AE_READABLE, process_recv,
c)</span><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:#888888'>//</span><span style='font-size:7.5pt;font-family:宋体;color:#888888'>注册</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>fd</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>的读事件，随时数据</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>}</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></b><b><span
lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>&nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>接收数据（</span></b><span
lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>process_recv</span><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>）</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp; &nbsp; &nbsp; &nbsp;</span><span style='font-size:8.5pt;
font-family:"微软雅黑","sans-serif";color:#333333'>接收数据函数<span lang=EN-US>process_recv</span>的实现直接影响着程序的性能，很多网络框架为实现通用，经常把判断是否构成一个数据包的逻辑抽象成一个函数给使用都注册。但是为了性能达到极至，定制化的服务器编程一般是可以提前计算这个数据包后面还有多少数据需要接收。一个高性能的网络服务器对一个<span
lang=EN-US>fd</span>而言，从<span lang=EN-US>recv</span>数据、数据包处理到<span lang=EN-US>send</span>数据几乎没有任何数据拷贝与线程的上下文切换。</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>void</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> process_recv(event_base *base, <b>int</b>
fd, <b>void</b> *privdata)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>{</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; </span><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:#888888'>//</span><span style='font-size:7.5pt;
font-family:宋体;color:#888888'>判断接收缓冲区大小</span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:#888888'>,</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>缓冲区太小进行扩大</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:#888888'>//</span><span style='font-size:7.5pt;font-family:宋体;color:#888888'>有的是使用接收缓冲的链接实现，有的是直接将内存扩大</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; ret = anetRead(c-&gt;fd, c-&gt;rbuf +
c-&gt;rlen, c-&gt;rtotal- c-&gt;rlen-</span><span lang=EN-US style='font-size:
7.5pt;font-family:Consolas;color:#008800'>1</span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:black'>);</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; </span><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:#888888'>//</span><span style='font-size:7.5pt;
font-family:宋体;color:#888888'>判断是否构成一个完整的数据包</span><span lang=EN-US
style='font-size:7.5pt;font-family:Consolas;color:#888888'>,</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>如果未构成一个完整的数据包，则返回继续接收数据</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; </span><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:#888888'>//</span><span style='font-size:7.5pt;
font-family:宋体;color:#888888'>如是多进程或者多线程并发模型里，直接调用处理函数进行包处理，减少上下文切换</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; </span><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:#888888'>//</span><span style='font-size:7.5pt;
font-family:宋体;color:#888888'>如果是单进程多处理线程的模型，则是将包放入任务处理队列，给</span><span
lang=EN-US style='font-size:7.5pt;font-family:Consolas;color:#888888'>worker</span><span
style='font-size:7.5pt;font-family:宋体;color:#888888'>线程进行处理</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; </span><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:#888888'>//</span><span style='font-size:7.5pt;
font-family:宋体;color:#888888'>注册此</span><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:#888888'>fd</span><span style='font-size:7.5pt;
font-family:宋体;color:#888888'>的超时定时器，如果客户端长时间不活动可踢除</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; register_timer(base, c-&gt;tevent,
MAX_TIMEOUT);</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>}</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><b><span lang=EN-US style='font-size:8.5pt;font-family:
"微软雅黑","sans-serif";color:#333333'>c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></b><b><span
lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>&nbsp;</span></b><b><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>发送数据（</span></b><span
lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>process_send</span><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>）</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>发送数据函数<span lang=EN-US>process_send</span>实现都差不多，需要注意的是如果这个<span
lang=EN-US>fd</span>所有数据都发送完成，一定要将写事件从事件框架中删除，否则会一直触发写事件。</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><b><span lang=EN-US style='font-size:7.5pt;font-family:
Consolas;color:black'>void</span></b><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:black'> process_send(event_base *base, <b>int</b>
fd, <b>void</b> *privdata)</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>{</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; anetWrite(c-&gt;fd, c-&gt;sbuf, c-&gt;slen);</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; </span><span lang=EN-US style='font-size:7.5pt;
font-family:Consolas;color:#888888'>//</span><span style='font-size:7.5pt;
font-family:宋体;color:#888888'>特别需要注册数据全部发送完成后，要注销写事件，否则会一般触发写事件的回调函数</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; <b>if</b>(</span><span style='font-size:7.5pt;
font-family:宋体;color:black'>数据全部发送完成</span><span lang=EN-US style='font-size:
7.5pt;font-family:Consolas;color:black'> )</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp; {</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event_del(base,
c-&gt;fd, AE_WRITABLE);</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:16.2pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>    }</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:7.5pt;font-family:Consolas;
color:black'>}</span></p>

<p class=MsoNormal align=left style='margin-top:0cm;margin-right:5.35pt;
margin-bottom:0cm;margin-left:5.35pt;margin-bottom:.0001pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:12.0pt;font-family:宋体;
color:#333333'>&nbsp;</span></p>

<h2><span style='font-family:宋体'>应用一</span><span lang=EN-US>:</span><span
style='font-family:宋体'>单进程实现</span><span lang=EN-US>tcpproxy</span></h2>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>与上层应用层协议完成无关的<span lang=EN-US>tcproxy</span>，在上面的<span
lang=EN-US>socket</span>封装（<span lang=EN-US>anet.cpp</span>）与事件驱动<span
lang=EN-US>(event.cpp)</span>的基础上增加<span lang=EN-US>300</span>行代码实现一个单进程的<span
lang=EN-US>tcp</span>代理模块。主要逻辑就是客户端连接上<span lang=EN-US>tcpproxy</span>后，创建客户端到<span
lang=EN-US>tcpproxy</span>的连接与异常连接代理的服务器。在<span lang=EN-US>process_recv</span>与<span
lang=EN-US>process_send</span>中就是对事件读写事件的切换。如从客户端接收到数据，触发<span lang=EN-US>proxy</span>到服务器端的写事件。如服务器端接收到数据，触发<span
lang=EN-US>proxy</span>到客户端的写事件。请参考附件中的<span lang=EN-US>tcpproxy </span>例子。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'><img width=456 height=156 id="图片 2"
src="https://github.com/Gwan-He/Gwan-He.github.io/blob/master/images/image004.jpg"
alt="http://avocado.oa.com/fconv/files/201412/78c69d92eb525bf45976e8974a2bf052.files/image004.jpg"></span></p>

<h2><span style='font-family:宋体'>应用二</span><span lang=EN-US>:</span><span
style='font-family:宋体'>多进程并发实现</span><span lang=EN-US>connsvr</span></h2>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span
lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>&nbsp;</span><span
style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";color:#333333'>实现一个多进程的并发处理框架。主进程创建子进程并监控子进程状态，每个子进程负责数据接收、处理与响应。请参考附件中的<span
lang=EN-US>connsvr</span>例子。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'><img width=457 height=203 id="图片 4"
src="https://github.com/Gwan-He/Gwan-He.github.io/blob/master/images/image005.jpg"
alt="http://avocado.oa.com/fconv/files/201412/78c69d92eb525bf45976e8974a2bf052.files/image005.jpg"></span><a
name="_GoBack"></a></p>

<h2><span style='font-family:宋体'>网络编程常见问题</span></h2>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>1</span><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>） 能否多个线程同时对一个<span lang=EN-US>fd</span>读或者写数据？<span lang=EN-US><br>
&nbsp; &nbsp; &nbsp;</span>除非使用锁互斥，否则不能，多个线程同时对一个<span lang=EN-US>fd</span>读，会导致收到数据乱序，处理起来会非常麻烦。写数据也一样，同时多个线程往一下<span
lang=EN-US>fd</span>发送数据，会导致发送数据乱序。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>2</span><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>） 怎样检查不活动的超时连接<span lang=EN-US>?<br>
&nbsp; &nbsp; &nbsp;</span>最简单的就是每隔一段时间，遍历所有连接，踢除超时连接，如<span lang=EN-US>lighttpd;</span>另一种方式是使用小根堆，注册到事件框架，连接超时时自动触发超时处理函数。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>3</span><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>） 什么时候将<span lang=EN-US>fd</span>读与写事件添加到事件驱动？<span lang=EN-US><br>
&nbsp; &nbsp; </span>因为服务器端不清楚什么时候客户会发送数据过来，除非你不想接收数据，否则一直都要将<span lang=EN-US>fd</span>的读事件添加到事件驱动；由于服务器端是很清楚什么时候需要发送数据，所以当有数据添加到<span
lang=EN-US>fd</span>的发送链表时，就要将写事件添加到事件驱动，发送完成后再删除。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>4</span><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>） 怎么保证一个<span lang=EN-US>fd</span>在收发大量数据，其它<span lang=EN-US>fd</span>不饿死？<span
lang=EN-US><br>
&nbsp; &nbsp; &nbsp;</span>可以每次只发送或者接收<span lang=EN-US>4K</span>数据，保证其他<span
lang=EN-US>fd</span>不会饿死。</span></p>

<p class=MsoNormal align=left style='margin-bottom:12.0pt;text-align:left;
line-height:15.45pt'><span lang=EN-US style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>5</span><span style='font-size:8.5pt;font-family:"微软雅黑","sans-serif";
color:#333333'>） 服务器能否直接调用<span lang=EN-US>send</span>发送数据，而不是将写事件添加到事件驱动，写事件触发后再调用<span
lang=EN-US>send</span>发送数据？<span lang=EN-US><br>
&nbsp; &nbsp; &nbsp;</span>可以，但是不建设这么做。监听写事件当数据可写时才会触发<span lang=EN-US>send</span>。假设客户接收数据的速度慢于服务器端发送数据的速度，<span
lang=EN-US>send</span>可能一直忙，如果直接调用<span lang=EN-US>send</span>发送数据一般会失败，就完成没有利用到多路<span
lang=EN-US>IO</span>复用的好处。</span></p>

</div>

</body>
